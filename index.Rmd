---
title: "Data Challenge"
author: "Jingjing Guo"
date: "Oct 30, 2017"
output:
  #pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Problem 1: Implementing priority queues and sorting
1. Index of the parent node of element i of the vector: $\lfloor \frac{i}{2} \rfloor$
Index of left child node of element i: $2i$
Index of right child node of element i: $2i + 1$

2. write a function of make_heap to return an empty heap
```{r}
make_heap <- function(LMAX) {
  heap0 <- c(rep(NA, LMAX))
  return(heap0)
}
# example:
LMAX <- 10
make_heap(LMAX)
```

3. Write a function to return the max element of the heap:
```{r}
max_heap <- function(heapx){
  max_element <- heapx[1]
  return(max_element)
}
# example
heapx = c(5,2,4,2,1)
max_heap(heapx)
```

4. write a function to remove the max element of the heap
```{r}
removeMax <- function(H){
  sizeNewH <- length(H) - 1
  newH <- H
  maxVal <- H[1]
  newH[1] <- newH[sizeNewH+1]
  newH <- head(newH, -1)

  curPos <- 1
  curLeftChi <- curPos * 2
  curRightChi <- curPos * 2 + 1

  while ( curRightChi <= sizeNewH && newH[curPos] < max(newH[c(curLeftChi, curRightChi)]) ){
    if (newH[curLeftChi] >= newH[curRightChi]){
      temp <- newH[curLeftChi]
      newH[curLeftChi] <- newH[curPos]
      newH[curPos] <- temp
      curPos <- curLeftChi
    }else{
      temp <- newH[curRightChi]
      newH[curRightChi] <- newH[curPos]
      newH[curPos] <- temp
      curPos <- curRightChi
    }
    curLeftChi <- curPos * 2
    curRightChi <- curPos * 2 + 1
  }
  if (curLeftChi==sizeNewH && newH[curPos]<newH[curLeftChi] ){
    temp <- newH[curLeftChi]
    newH[curLeftChi] <- newH[curPos]
    newH[curPos] <- temp
    curPos <- curLeftChi 
  }
  return(newH)
}

H <- c(10,6,9,4,5,8,2)
newH <- removeMax(H)
newH
```